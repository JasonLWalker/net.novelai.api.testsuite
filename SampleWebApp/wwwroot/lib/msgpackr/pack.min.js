/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/msgpackr@1.10.1/pack.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{Unpackr,mult10,C1Type,typedArrays,addExtension as unpackAddExtension}from"./unpack.js";let textEncoder,extensions,extensionClasses;try{textEncoder=new TextEncoder}catch(t){}const hasNodeBuffer="undefined"!=typeof Buffer,ByteArrayAllocate=hasNodeBuffer?function(t){return Buffer.allocUnsafeSlow(t)}:Uint8Array,ByteArray=hasNodeBuffer?Buffer:Uint8Array,MAX_BUFFER_SIZE=hasNodeBuffer?4294967296:2144337920;let target,keysTarget,targetView,safeEnd,writeStructSlots,position=0,bundledStrings=null;const MAX_BUNDLE_SIZE=21760,hasNonLatin=/[\u0080-\uFFFF]/;export const RECORD_SYMBOL=Symbol("record-id");export class Packr extends Unpackr{constructor(t){let e,i,o,r;super(t),this.offset=0;let n=ByteArray.prototype.utf8Write?function(t,e){return target.utf8Write(t,e,4294967295)}:!(!textEncoder||!textEncoder.encodeInto)&&function(t,e){return textEncoder.encodeInto(t,target.subarray(e)).written},s=this;t||(t={});let a=t&&t.sequential,g=t.structures||t.saveStructures,p=t.maxSharedStructures;if(null==p&&(p=g?32:0),p>8160)throw new Error("Maximum maxSharedStructure is 8160");t.structuredClone&&null==t.moreTypes&&(this.moreTypes=!0);let l=t.maxOwnStructures;null==l&&(l=g?32:64),this.structures||0==t.useRecords||(this.structures=[]);let u=p>32||l+p>64,f=p+64,c=p+l+64;if(c>8256)throw new Error("Maximum maxSharedStructure + maxOwnStructure is 8192");let d=[],h=0,w=0;this.pack=this.encode=function(t,n){if(target||(target=new ByteArrayAllocate(8192),targetView=target.dataView||(target.dataView=new DataView(target.buffer,0,8192)),position=0),safeEnd=target.length-10,safeEnd-position<2048?(target=new ByteArrayAllocate(target.length),targetView=target.dataView||(target.dataView=new DataView(target.buffer,0,target.length)),safeEnd=target.length-10,position=0):position=position+7&2147483640,e=position,n&RESERVE_START_SPACE&&(position+=255&n),r=s.structuredClone?new Map:null,s.bundleStrings&&"string"!=typeof t?(bundledStrings=[],bundledStrings.size=1/0):bundledStrings=null,o=s.structures,o){o.uninitialized&&(o=s._mergeStructures(s.getStructures()));let t=o.sharedLength||0;if(t>p)throw new Error("Shared structures is larger than maximum shared structures, try increasing maxSharedStructures to "+o.sharedLength);if(!o.transitions){o.transitions=Object.create(null);for(let e=0;e<t;e++){let t=o[e];if(!t)continue;let i,r=o.transitions;for(let e=0,o=t.length;e<o;e++){let o=t[e];i=r[o],i||(i=r[o]=Object.create(null)),r=i}r[RECORD_SYMBOL]=e+64}this.lastNamedStructuresLength=t}a||(o.nextId=t+64)}let g;i&&(i=!1);try{s.randomAccessStructure&&t&&t.constructor&&t.constructor===Object?k(t):E(t);let i=bundledStrings;if(bundledStrings&&writeBundles(e,E,0),r&&r.idsToInsert){let t=r.idsToInsert.sort(((t,e)=>t.offset>e.offset?1:-1)),o=t.length,n=-1;for(;i&&o>0;){let r=t[--o].offset+e;r<i.stringsPosition+e&&-1===n&&(n=0),r>i.position+e?n>=0&&(n+=6):(n>=0&&(targetView.setUint32(i.position+e,targetView.getUint32(i.position+e)+n),n=-1),i=i.previous,o++)}n>=0&&i&&targetView.setUint32(i.position+e,targetView.getUint32(i.position+e)+n),position+=6*t.length,position>safeEnd&&O(position),s.offset=position;let a=insertIds(target.subarray(e,position),t);return r=null,a}return s.offset=position,n&REUSE_BUFFER_MODE?(target.start=e,target.end=position,target):target.subarray(e,position)}catch(t){throw g=t,t}finally{if(o&&(y(),i&&s.saveStructures)){let i=o.sharedLength||0,r=target.subarray(e,position),a=prepareStructures(o,s);if(!g)return!1===s.saveStructures(a,a.isCompatible)?s.pack(t,n):(s.lastNamedStructuresLength=i,r)}n&RESET_BUFFER_MODE&&(position=e)}};const y=()=>{w<10&&w++;let t=o.sharedLength||0;if(o.length>t&&!a&&(o.length=t),h>1e4)o.transitions=null,w=0,h=0,d.length>0&&(d=[]);else if(d.length>0&&!a){for(let t=0,e=d.length;t<e;t++)d[t][RECORD_SYMBOL]=0;d=[]}},S=t=>{var e=t.length;e<16?target[position++]=144|e:e<65536?(target[position++]=220,target[position++]=e>>8,target[position++]=255&e):(target[position++]=221,targetView.setUint32(position,e),position+=4);for(let i=0;i<e;i++)E(t[i])},E=t=>{position>safeEnd&&(target=O(position));var i,o=typeof t;if("string"===o){let o,r=t.length;if(bundledStrings&&r>=4&&r<4096){if((bundledStrings.size+=r)>21760){let t,i,o=(bundledStrings[0]?3*bundledStrings[0].length+bundledStrings[1].length:0)+10;position+o>safeEnd&&(target=O(position+o)),bundledStrings.position?(i=bundledStrings,target[position]=200,position+=3,target[position++]=98,t=position-e,position+=4,writeBundles(e,E,0),targetView.setUint16(t+e-3,position-e-t)):(target[position++]=214,target[position++]=98,t=position-e,position+=4),bundledStrings=["",""],bundledStrings.previous=i,bundledStrings.size=0,bundledStrings.position=t}let i=hasNonLatin.test(t);return bundledStrings[i?0:1]+=t,target[position++]=193,void E(i?-r:r)}o=r<32?1:r<256?2:r<65536?3:5;let s=3*r;if(position+s>safeEnd&&(target=O(position+s)),r<64||!n){let e,n,s,a=position+o;for(e=0;e<r;e++)n=t.charCodeAt(e),n<128?target[a++]=n:n<2048?(target[a++]=n>>6|192,target[a++]=63&n|128):55296==(64512&n)&&56320==(64512&(s=t.charCodeAt(e+1)))?(n=65536+((1023&n)<<10)+(1023&s),e++,target[a++]=n>>18|240,target[a++]=n>>12&63|128,target[a++]=n>>6&63|128,target[a++]=63&n|128):(target[a++]=n>>12|224,target[a++]=n>>6&63|128,target[a++]=63&n|128);i=a-position-o}else i=n(t,position+o);i<32?target[position++]=160|i:i<256?(o<2&&target.copyWithin(position+2,position+1,position+1+i),target[position++]=217,target[position++]=i):i<65536?(o<3&&target.copyWithin(position+3,position+2,position+2+i),target[position++]=218,target[position++]=i>>8,target[position++]=255&i):(o<5&&target.copyWithin(position+5,position+3,position+3+i),target[position++]=219,targetView.setUint32(position,i),position+=4),position+=i}else if("number"===o)if(t>>>0===t)t<32||t<128&&!1===this.useRecords||t<64&&!this.randomAccessStructure?target[position++]=t:t<256?(target[position++]=204,target[position++]=t):t<65536?(target[position++]=205,target[position++]=t>>8,target[position++]=255&t):(target[position++]=206,targetView.setUint32(position,t),position+=4);else if(t>>0===t)t>=-32?target[position++]=256+t:t>=-128?(target[position++]=208,target[position++]=t+256):t>=-32768?(target[position++]=209,targetView.setInt16(position,t),position+=2):(target[position++]=210,targetView.setInt32(position,t),position+=4);else{let e;if((e=this.useFloat32)>0&&t<4294967296&&t>=-2147483648){let i;if(target[position++]=202,targetView.setFloat32(position,t),e<4||(i=t*mult10[(127&target[position])<<1|target[position+1]>>7])>>0===i)return void(position+=4);position--}target[position++]=203,targetView.setFloat64(position,t),position+=8}else if("object"===o||"function"===o)if(t){if(r){let i=r.get(t);if(i){if(!i.id){let t=r.idsToInsert||(r.idsToInsert=[]);i.id=t.push(i)}return target[position++]=214,target[position++]=112,targetView.setUint32(position,i.id),void(position+=4)}r.set(t,{offset:position-e})}let n=t.constructor;if(n===Object)B(t,!0);else if(n===Array)S(t);else if(n===Map)if(this.mapAsEmptyObject)target[position++]=128;else{(i=t.size)<16?target[position++]=128|i:i<65536?(target[position++]=222,target[position++]=i>>8,target[position++]=255&i):(target[position++]=223,targetView.setUint32(position,i),position+=4);for(let[e,i]of t)E(e),E(i)}else{for(let e=0,i=extensions.length;e<i;e++){if(t instanceof extensionClasses[e]){let i=extensions[e];if(i.write){i.type&&(target[position++]=212,target[position++]=i.type,target[position++]=0);let e=i.write.call(this,t);return void(e===t?Array.isArray(t)?S(t):B(t):E(e))}let o,r=target,n=targetView,s=position;target=null;try{o=i.pack.call(this,t,(t=>(target=r,r=null,position+=t,position>safeEnd&&O(position),{target:target,targetView:targetView,position:position-t})),E)}finally{r&&(target=r,targetView=n,position=s,safeEnd=target.length-10)}return void(o&&(o.length+position>safeEnd&&O(o.length+position),position=writeExtensionData(o,target,position,i.type)))}}if(Array.isArray(t))S(t);else{if(t.toJSON){const e=t.toJSON();if(e!==t)return E(e)}if("function"===o)return E(this.writeFunction&&this.writeFunction(t));B(t,!t.hasOwnProperty)}}}else target[position++]=192;else if("boolean"===o)target[position++]=t?195:194;else if("bigint"===o){if(t<BigInt(1)<<BigInt(63)&&t>=-(BigInt(1)<<BigInt(63)))target[position++]=211,targetView.setBigInt64(position,t);else if(t<BigInt(1)<<BigInt(64)&&t>0)target[position++]=207,targetView.setBigUint64(position,t);else{if(!this.largeBigIntToFloat){if(this.useBigIntExtension&&t<2n**1023n&&t>-(2n**1023n)){target[position++]=199,position++,target[position++]=66;let e,i=[];do{let o=0xffn&t;e=(0x80n&o)===(t<0n?0x80n:0n),i.push(o),t>>=8n}while(0n!==t&&-1n!==t||!e);target[position-2]=i.length;for(let t=i.length;t>0;)target[position++]=Number(i[--t]);return}throw new RangeError(t+" was too large to fit in MessagePack 64-bit integer format, use useBigIntExtension or set largeBigIntToFloat to convert to float-64")}target[position++]=203,targetView.setFloat64(position,Number(t))}position+=8}else{if("undefined"!==o)throw new Error("Unknown type: "+o);this.encodeUndefinedAsNil?target[position++]=192:(target[position++]=212,target[position++]=0,target[position++]=0)}},b=this.variableMapSize||this.coercibleKeyAsNumber?t=>{let e,i=Object.keys(t),o=i.length;if(o<16?target[position++]=128|o:o<65536?(target[position++]=222,target[position++]=o>>8,target[position++]=255&o):(target[position++]=223,targetView.setUint32(position,o),position+=4),this.coercibleKeyAsNumber)for(let r=0;r<o;r++){e=i[r];let o=Number(e);E(isNaN(o)?e:o),E(t[e])}else for(let r=0;r<o;r++)E(e=i[r]),E(t[e])}:(t,i)=>{target[position++]=222;let o=position-e;position+=2;let r=0;for(let e in t)(i||t.hasOwnProperty(e))&&(E(e),E(t[e]),r++);target[o+++e]=r>>8,target[o+e]=255&r},m=!1===this.useRecords?b:t.progressiveRecords&&!u?(t,i)=>{let r,n,s=o.transitions||(o.transitions=Object.create(null)),a=position++-e;for(let g in t)if(i||t.hasOwnProperty(g)){if(r=s[g],r)s=r;else{let i=Object.keys(t),p=s;s=o.transitions;let l=0;for(let t=0,e=i.length;t<e;t++){let e=i[t];r=s[e],r||(r=s[e]=Object.create(null),l++),s=r}a+e+1==position?(position--,A(s,i,l)):V(s,i,a,l),n=!0,s=p[g]}E(t[g])}if(!n){let i=s[RECORD_SYMBOL];i?target[a+e]=i:V(s,Object.keys(t),a,0)}}:(t,e)=>{let i,r=o.transitions||(o.transitions=Object.create(null)),n=0;for(let o in t)(e||t.hasOwnProperty(o))&&(i=r[o],i||(i=r[o]=Object.create(null),n++),r=i);let s=r[RECORD_SYMBOL];s?s>=96&&u?(target[position++]=96+(31&(s-=96)),target[position++]=s>>5):target[position++]=s:A(r,r.__keys__||Object.keys(t),n);for(let i in t)(e||t.hasOwnProperty(i))&&E(t[i])},x="function"==typeof this.useRecords&&this.useRecords,B=x?(t,e)=>{x(t)?m(t,e):b(t,e)}:m,O=t=>{let i;if(t>16777216){if(t-e>MAX_BUFFER_SIZE)throw new Error("Packed buffer would be larger than maximum buffer size");i=Math.min(MAX_BUFFER_SIZE,4096*Math.round(Math.max((t-e)*(t>67108864?1.25:2),4194304)/4096))}else i=1+(Math.max(t-e<<2,target.length-1)>>12)<<12;let o=new ByteArrayAllocate(i);return targetView=o.dataView||(o.dataView=new DataView(o.buffer,0,i)),t=Math.min(t,target.length),target.copy?target.copy(o,0,e,t):o.set(target.slice(e,t)),position-=e,e=0,safeEnd=o.length-10,target=o},A=(t,e,r)=>{let n=o.nextId;n||(n=64),n<f&&this.shouldShareStructure&&!this.shouldShareStructure(e)?(n=o.nextOwnId,n<c||(n=f),o.nextOwnId=n+1):(n>=c&&(n=f),o.nextId=n+1);let s=e.highByte=n>=96&&u?n-96>>5:-1;t[RECORD_SYMBOL]=n,t.__keys__=e,o[n-64]=e,n<f?(e.isShared=!0,o.sharedLength=n-63,i=!0,s>=0?(target[position++]=96+(31&n),target[position++]=s):target[position++]=n):(s>=0?(target[position++]=213,target[position++]=114,target[position++]=96+(31&n),target[position++]=s):(target[position++]=212,target[position++]=114,target[position++]=n),r&&(h+=w*r),d.length>=l&&(d.shift()[RECORD_SYMBOL]=0),d.push(t),E(e))},V=(t,i,o,r)=>{let n=target,s=position,a=safeEnd,g=e;target=keysTarget,position=0,e=0,target||(keysTarget=target=new ByteArrayAllocate(8192)),safeEnd=target.length-10,A(t,i,r),keysTarget=target;let p=position;if(target=n,position=s,safeEnd=a,e=g,p>1){let t=position+p-1;t>safeEnd&&O(t);let i=o+e;target.copyWithin(i+p,i+1,position),target.set(keysTarget.slice(0,p),i),position=t}else target[o+e]=keysTarget[0]},k=(t,r)=>{let n=writeStructSlots(t,target,e,position,o,O,((t,e,o)=>{if(o)return i=!0;position=e;let r=target;return E(t),y(),r!==target?{position:position,targetView:targetView,target:target}:position}),this);if(0===n)return B(t,!0);position=n}}useBuffer(t){target=t,targetView=new DataView(target.buffer,target.byteOffset,target.byteLength),position=0}clearSharedData(){this.structures&&(this.structures=[]),this.typedStructs&&(this.typedStructs=[])}}function copyBinary(t,e,i,o,r){for(;o<r;)e[i++]=t[o++]}function writeExtBuffer(t,e,i,o){let r=t.byteLength;if(r+1<256){var{target:n,position:s}=i(4+r);n[s++]=199,n[s++]=r+1}else if(r+1<65536){var{target:n,position:s}=i(5+r);n[s++]=200,n[s++]=r+1>>8,n[s++]=r+1&255}else{var{target:n,position:s,targetView:a}=i(7+r);n[s++]=201,a.setUint32(s,r+1),s+=4}n[s++]=116,n[s++]=e,n.set(new Uint8Array(t.buffer,t.byteOffset,t.byteLength),s)}function writeBuffer(t,e){let i=t.byteLength;var o,r;if(i<256){var{target:o,position:r}=e(i+2);o[r++]=196,o[r++]=i}else if(i<65536){var{target:o,position:r}=e(i+3);o[r++]=197,o[r++]=i>>8,o[r++]=255&i}else{var{target:o,position:r,targetView:n}=e(i+5);o[r++]=198,n.setUint32(r,i),r+=4}o.set(t,r)}function writeExtensionData(t,e,i,o){let r=t.length;switch(r){case 1:e[i++]=212;break;case 2:e[i++]=213;break;case 4:e[i++]=214;break;case 8:e[i++]=215;break;case 16:e[i++]=216;break;default:r<256?(e[i++]=199,e[i++]=r):r<65536?(e[i++]=200,e[i++]=r>>8,e[i++]=255&r):(e[i++]=201,e[i++]=r>>24,e[i++]=r>>16&255,e[i++]=r>>8&255,e[i++]=255&r)}return e[i++]=o,e.set(t,i),i+=r}function insertIds(t,e){let i,o=6*e.length,r=t.length-o;for(;i=e.pop();){let e=i.offset,n=i.id;t.copyWithin(e+o,e,r),o-=6;let s=e+o;t[s++]=214,t[s++]=105,t[s++]=n>>24,t[s++]=n>>16&255,t[s++]=n>>8&255,t[s++]=255&n,r=e}return t}function writeBundles(t,e,i){if(bundledStrings.length>0){targetView.setUint32(bundledStrings.position+t,position+i-bundledStrings.position-t),bundledStrings.stringsPosition=position-t;let o=bundledStrings;bundledStrings=null,e(o[0]),e(o[1])}}extensionClasses=[Date,Set,Error,RegExp,ArrayBuffer,Object.getPrototypeOf(Uint8Array.prototype).constructor,C1Type],extensions=[{pack(t,e,i){let o=t.getTime()/1e3;if((this.useTimestamp32||0===t.getMilliseconds())&&o>=0&&o<4294967296){let{target:t,targetView:i,position:r}=e(6);t[r++]=214,t[r++]=255,i.setUint32(r,o)}else if(o>0&&o<4294967296){let{target:i,targetView:r,position:n}=e(10);i[n++]=215,i[n++]=255,r.setUint32(n,4e6*t.getMilliseconds()+(o/1e3/4294967296>>0)),r.setUint32(n+4,o)}else if(isNaN(o)){if(this.onInvalidDate)return e(0),i(this.onInvalidDate());let{target:t,targetView:o,position:r}=e(3);t[r++]=212,t[r++]=255,t[r++]=255}else{let{target:i,targetView:r,position:n}=e(15);i[n++]=199,i[n++]=12,i[n++]=255,r.setUint32(n,1e6*t.getMilliseconds()),r.setBigInt64(n+4,BigInt(Math.floor(o)))}}},{pack(t,e,i){if(this.setAsEmptyObject)return e(0),i({});let o=Array.from(t),{target:r,position:n}=e(this.moreTypes?3:0);this.moreTypes&&(r[n++]=212,r[n++]=115,r[n++]=0),i(o)}},{pack(t,e,i){let{target:o,position:r}=e(this.moreTypes?3:0);this.moreTypes&&(o[r++]=212,o[r++]=101,o[r++]=0),i([t.name,t.message])}},{pack(t,e,i){let{target:o,position:r}=e(this.moreTypes?3:0);this.moreTypes&&(o[r++]=212,o[r++]=120,o[r++]=0),i([t.source,t.flags])}},{pack(t,e){this.moreTypes?writeExtBuffer(t,16,e):writeBuffer(hasNodeBuffer?Buffer.from(t):new Uint8Array(t),e)}},{pack(t,e){let i=t.constructor;i!==ByteArray&&this.moreTypes?writeExtBuffer(t,typedArrays.indexOf(i.name),e):writeBuffer(t,e)}},{pack(t,e){let{target:i,position:o}=e(1);i[o]=193}}];export function addExtension(t){if(t.Class){if(!t.pack&&!t.write)throw new Error("Extension has no pack or write function");if(t.pack&&!t.type)throw new Error("Extension has no type (numeric code to identify the extension)");extensionClasses.unshift(t.Class),extensions.unshift(t)}unpackAddExtension(t)}function prepareStructures(t,e){return t.isCompatible=t=>{let i=!t||(e.lastNamedStructuresLength||0)===t.length;return i||e._mergeStructures(t),i},t}export function setWriteStructSlots(t,e){writeStructSlots=t,prepareStructures=e}let defaultPackr=new Packr({useRecords:!1});export const pack=defaultPackr.pack;export const encode=defaultPackr.pack;export const Encoder=Packr;export{FLOAT32_OPTIONS}from"./unpack.js";import{FLOAT32_OPTIONS}from"./unpack.js";export const{NEVER:NEVER,ALWAYS:ALWAYS,DECIMAL_ROUND:DECIMAL_ROUND,DECIMAL_FIT:DECIMAL_FIT}=FLOAT32_OPTIONS;export const REUSE_BUFFER_MODE=512;export const RESET_BUFFER_MODE=1024;export const RESERVE_START_SPACE=2048;
//# sourceMappingURL=/sm/8f0ac61c0b7cd498a119445df9e1785482e3190f39938c323bc83b3df9000989.map